/*

# SECTION 11 - MODELING DATA and ADVANCED MONGOOSE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////



# ⎛⎝(•‿•)⎠⎞
#   148. MongoDB Data Modelling
#   149. Designing Our Data Model
#   150. Modelling Locations (Geospatial Data)
#   151. Modelling Tour Guides: Embedding
#   152. Modelling Tour Guides: Child #   Referencing
#   153. Populating Tour Guides
#   154. Modelling Reviews: Parent Referencing
#   155. Creating and Getting Reviews
#   156. Populating Reviews
#   157. Virtual Populate: Tours and Reviews
#   158. Implementing Simple Nested Routes
#   159. Nested Routes with Express
#   160. Adding a Nested GET Endpoint
#   161. Building Handler Factory Functions: #  Delete
#   162. Factory Functions: Update and Create
#   163. Factory Functions: Reading
#   164. Adding a /me Endpoint
#   165. Adding Missing Authentication and #  Authorization
#   166. Importing Review and User Data
#   167. Improving Read Performance with #  Indexes
#   168. Calculating Average Rating on Tours - #  Part 1
#   169. Calculating Average Rating on Tours - #  Part 2
#   170. Preventing Duplicate Reviews
#   171. Geospatial Queries: Finding Tours #  Within Radius
#   172. Geospatial Aggregation: Calculating #  Distances
#   173. Creating API Documentation Using #   Postman


//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////


#   148. MongoDB Data Modelling
>> Data modeling is the process of taking unstructured data generated by a real world scenario and then structure it into a logical data model in database.

->  1. Types of Relationships between Data
>> One to One (1: 1)
>> One to Many(1: MANY)
  ? 1: FEW
  ? 1: MANY
  ? 1: TON
*  By the way; in relational databases there is just one to many without quantifying how much that many actually is. In MongoDB databases though it is an extremely important difference. Because its one of the factors that we're gonna use to decide if we should denormalize or normalize data.

>> Many to Many (MANY: MANY)

->  2.   REFERENCING (NORMALIZING) VS. EMBEDDING (DENORMALIZING)
>> REFERENCING / NORMALIZE ->  
* In referencing we keep two related datasets and all the documents separated. 
* Data is nicely separated which is exactly what normalized means.

>> EMBEDDED / DENORMALIZE ->
* If we choose to denormalize or to embed our data we will have one main document containing all the main data as well as the related data.

->  3. WHEN TO EMBED AND WHEN TO REFERENCE? 
>> 1. RELATIONSHIP TYPE (How two datasets are related to each other)
>> 2. DATA ACCESS PATTERNS (how often data is read and written. Read/write ratio)
>> 3. DATA CLOSENESS (how "much" the data is related, how we want to query)

->> EMBEDDING 
>> Relationship type       
>> 👉 1:MANY, 
>> 👉 1:FEW

>> Data access pattern -  
>> 👉 Data is mostly read 
>> 👉 Data does not change quickly
>> 👉 High read/write ratio

>> Data closeness - 
>> 👉 Datasets really belong together


->> REFERENCING
>> Relationship type        
>> 👉 1: MANY
>> 👉 1: TON
>> 👉 MANY:MANY

>> Data access pattern -  
>> 👉 Data is updated a lot
>> 👉 Low read/write ratio

>> Data closeness - 
>> 👉 We frequently need to query both datasets on their own


->  4. TYPES OF REFERENCING
>> 👉 CHILD REFERENCING
>> 👉 PARENT REFERENCING
>> 👉 TWO-WAY REFERENCING

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

#   149. Designing Our Data Model

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#   150. Modelling Locations (Geospatial Data)
>> MongoDB supports geospatial data out of the box. Geospatial data is basically data that describes places on earth using longitude and latitude coordinates.
-> MongoDB uses a special data format called GeoJSON.

 startLocation: {
      //GeoJSON
      type: {
        type: String,
        default: 'Point', //Polygon, line
        enum: ['Point'],
      },
      coordinates: [Number]}, // longitude first then latitude
    },
?Well, this object is not for the schema type options
? In order for this object to be recognized as geospatial JSON, we need the type and the coordinates properties
? And so now, each of these fields here, so basically, each of these sub-fields is then gonna get its own schema type options.
IMPORTANT In GeoJSON coordinates we take longitude first then latitude.

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
#   151. Modelling Tour Guides: Embedding
-> { type: mongoose.Schema.ObjectId,
->    ref: 'User'} -  we expect a mongodb id from user schema

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#   152. Modelling Tour Guides: Child Referencing
-> use .populate({path: 'guides', 
->                select: '- __v'}) on getTour in tourController

>> Populate might still take a hit on performance as it creates a new query


///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#   157. Virtual Populate: Tours and Reviews
-> With virtual populate we can populate all the reviews on the tour without keeping the ids on the tour.

* In tourModel.js
>> foreignField -> name of the field in reviewSchema which will have the tour id 
>> localField -> name of the field in the tourModel

tourSchema.virtual('reviews', {
  ref: 'Review',
  foreignField: 'tour',
  localField: '_id',
});

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#   158. Implementing Simple Nested Routes
>> Nested routes
 // POST /Parent/P_Id/Child
 // POST /tour/3536fad3/reviews
 // GET /tour/3536fad3/reviews
 // GET /tour/3536fad3/reviews/947755fd

 
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
#   159. Nested Routes with Express
#   160. Adding a Nested GET Endpoint

 
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#   161. Building Handler Factory Functions: #  Delete

>>  Adding very similar handlers to all of our controllers will create a lot of duplicate code.

>> Because all these update handlers, or all these delete handlers, or all these create handlers, they really all just look basically the same, right?

? Also, imagine that we wanted to change like some https status code or status message. Then we would have to go into each and every controller and then change all the handlers in there. And so, instead of manually writing all these handlers, why not simply create a factory function that's gonna return these handlers for us? So, a factory function is exactly that.
-> FACTORY FUNCTION - It's a function that returns another function, and in this case our handler function. So, for deleting, for creating, for updating, and also for reading resources. 

#   162. Factory Functions: Update and Create
#   163. Factory Functions: Reading
 
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#   164. Adding a /me Endpoint
#   165. Adding Missing Authentication and #  Authorization
#   166. Importing Review and User Data

-> In order to prevent turning off password encryption, I set a new value for the NODE_ENV variable to LOADER in my config.env file.

NODE_ENV=LOADER

-> After that, I implemented a new block in my userModel.js asking for the NODE_ENV and set this.isNew to true:



if(process.env.NODE_ENV === 'LOADER'){
        this.isNew = true;
        return next();
}
-> Finally, the function looks like:

userSchema.pre('save', async function(next){
 
    //Only run this function if password was actually modified
    if(!this.isModified('password')) return next();
 
    if(process.env.NODE_ENV === 'LOADER'){
        this.isNew = true;
        return next();
    }
    // Hash the password with cost of 12
    this.password = await bcrypt.hash(this.password,12);
 
    //Delete passwordConfirm field
    this.passwordConfirm = undefined;
 
    next();
 
});
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#   167. Improving Read Performance with #  Indexes
IMPORTANT 
-> CHECK VIDEO

#   168. Calculating Average Rating on Tours - #  Part 1
#   169. Calculating Average Rating on Tours - #  Part 2
#   170. Preventing Duplicate Reviews
#   171. Geospatial Queries: Finding Tours #  Within Radius
#   172. Geospatial Aggregation: Calculating #  Distances
#   173. Creating API Documentation Using #   Postman
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

*/
